<!doctype html>
<html lang="vi">
    <head>
    <title>
         Thu thập log từ Cisco IOS về SIEM (ELK) | ctnguyenvn 
    </title>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    
    <meta property="og:description" content="Trong thực tế đối với các thiết bị như router/switch các team network/system sẽ sử dụng một số công cụ như zabbix, SolarWinds, Nagios… để tích hợp nhằm mục đích monitoring (thường sẽ là traffic/status interface…). Tuy nhiên hôm nay tôi có nhu cầu thu thập nhật ký audit/logon/history command… nhằm phục vụ công việc ghi nhận nhật ký login, thao tác của tài khoản quản trị trên các thiết bị router/switch này.

Sơ lược mô hình

Trong bài viết này tôi sẽ chia sẻ một bài Lab nhỏ nhằm thu thập một số nhật ký cần thiết trên các thiết bị router/switch về hệ thống SIEM. Cụ thể tôi sẽ sử dụng IOS Version 12.4 Router 3700 Software (C3725-ADVENTERPRISEK9-M) giả lập trên phần mềm GNS3 kết hợp với ELK. ELK được build trên docker theo mô hình AIO và được cài đặt trên máy ảo vmware chạy hệ điều hành CentOS 7.

Mô hình cơ bản như sau




  Lưu ý: Hiện tại tôi gửi log về logstash nhằm mục đích parse manual, tuy nhiên thực tế hiện tại filebeat có module cisco tương đối đủ để auto parse mà không cần parse tay ở logstash. Ngược lại với cách này yêu cầu dựng 1 server trung gian khác chạy filebeat để listen nên tôi không đề cập trong bài viết này.


" />
    
    <meta name="author" content="ctnguyenvn" />
    
    <meta property="og:title" content="Thu thập log từ Cisco IOS về SIEM (ELK) - Happy Investigating" />
    <meta property="twitter:title" content="Thu thập log từ Cisco IOS về SIEM (ELK) - Happy Investigating" />
     
    <meta property="og:image" content="https://ctnguyenvn.github.io/assets/img/ctnguyenvn.webp" />
    <meta property="twitter:image" content="https://ctnguyenvn.github.io/assets/img/ctnguyenvn.webp" />
    
    <meta property="og:site_name" content="ctnguyenvn - System security" />
    <!-- <link rel="stylesheet" type="text/css" href="https://ctnguyenvn.github.io/assets/css/bulma.min.css" /> -->
	<script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" type="text/css" href="https://ctnguyenvn.github.io/assets/css/styles.css" />
    <link rel="stylesheet" type="text/css" href="https://ctnguyenvn.github.io/assets/css/highlight.css" />
    <link href="https://fonts.googleapis.com/css2?family=Play:wght@400;700&display=swap" rel="stylesheet" />
    <link
        rel="alternate"
        type="application/rss+xml"
        title=" - Happy Investigating"
        href="https://ctnguyenvn.github.io/feed.xml"
    />
    <link rel="canonical" href="https://ctnguyenvn.github.io/2023/02/collect-log-from-cisco-ios-to-ELK/" />
    <meta name="theme-color" content="#000000" />
    <link rel="icon" type="image/png" sizes="32x32" href="https://ctnguyenvn.github.io/assets/img/ctnguyenvn.png" />
        
</head>

    <body>
		<div>
			<div class="border-b"><nav class="max-w-screen-lg mx-auto flex justify-between items-center p-4">
    <div class="">
        <a href="https://ctnguyenvn.github.io">
            <img src="https://ctnguyenvn.github.io/assets/img/ctnguyenvn.png" class="h-6" alt="ctnguyenvn" />
        </a>
    </div>
    <div class="hidden md:flex justify-center gap-6">
        <a href="/" class="text-xs font-medium uppercase px-2 hover:text-yellow-400">Home</a>
        <a href="/" class="text-xs font-medium uppercase px-2 hover:text-yellow-400">Blog</a>
        <a href="/projects" class="text-xs font-medium uppercase px-2 hover:text-yellow-400">Projects</a>
        <a href="/about" class="text-xs font-medium uppercase px-2 hover:text-yellow-400">About</a>
    </div>
    <div class="flex gap-4">
        <a href="https://github.com/ctnguyenvn" class="hover:text-yellow-400">
            <i class="bi bi-github"></i>
        </a>
        <a href="https://twitter.com/ctnguyenvn" class="hover:text-yellow-400">
            <i class="bi bi-twitter"></i>
        </a>
        <a href="https://t.me/ctnguyenvn" class="hover:text-yellow-400">
            <i class="bi bi-telegram"></i>
        </a>
    </div>
</nav>
</div>
			<main><div class="max-w-screen-lg mx-auto my-2 py-2 md:my-6 md:py-6 px-4">
    <div class="text-center pt-4">
        <p>
             
            <a class="text-sm bg-yellow-300 px-2 py-1 rounded px mx-1 hover:opacity-90" href="/tag/collect-log">collect-log</a>
             
            <a class="text-sm bg-yellow-300 px-2 py-1 rounded px mx-1 hover:opacity-90" href="/tag/elk">ELK</a>
             
        </p>
        <h1 class="text-4xl font-semibold pt-1 pb-2">
            <a href="/2023/02/collect-log-from-cisco-ios-to-ELK/" class="is-size-3 has-text-black-ter has-text-weight-semibold">Thu thập log từ Cisco IOS về SIEM (ELK)</a>
        </h1>
        <div class="text-md pt-1">
            <span class="text-gray-400">Posted by</span>
            <a href="https://ctnguyenvn.github.io/about" class="text-[#007cc3]">ctnguyenvn</a>
            <span class="text-gray-400">on</span>
            <i class="bi bi-clock px-1 text-gray-400 text-sm"></i>
            <span class="text-[#007cc3]">22 February, 2023</span>
        </div>
    </div>
    <div class="content my-4 py-4"><p>Trong thực tế đối với các thiết bị như router/switch các team network/system sẽ sử dụng một số công cụ như zabbix, SolarWinds, Nagios… để tích hợp nhằm mục đích monitoring (thường sẽ là traffic/status interface…). Tuy nhiên hôm nay tôi có nhu cầu thu thập nhật ký audit/logon/history command… nhằm phục vụ công việc ghi nhận nhật ký login, thao tác của tài khoản quản trị trên các thiết bị router/switch này.</p>

<h3 id="sơ-lược-mô-hình">Sơ lược mô hình</h3>

<p>Trong bài viết này tôi sẽ chia sẻ một bài Lab nhỏ nhằm thu thập một số nhật ký cần thiết trên các thiết bị router/switch về hệ thống SIEM. Cụ thể tôi sẽ sử dụng IOS Version 12.4 Router 3700 Software (C3725-ADVENTERPRISEK9-M) giả lập trên phần mềm GNS3 kết hợp với ELK. ELK được build trên docker theo mô hình AIO và được cài đặt trên máy ảo vmware chạy hệ điều hành CentOS 7.</p>

<p>Mô hình cơ bản như sau</p>

<p><img src="/images/ELK/cisco/1.png" alt="" /></p>

<blockquote>
  <p>Lưu ý: Hiện tại tôi gửi log về logstash nhằm mục đích parse manual, tuy nhiên thực tế hiện tại filebeat có module cisco tương đối đủ để auto parse mà không cần parse tay ở logstash. Ngược lại với cách này yêu cầu dựng 1 server trung gian khác chạy filebeat để listen nên tôi không đề cập trong bài viết này.</p>
</blockquote>

<!--more-->

<h3 id="start-elk-docker-version">Start ELK (docker version)</h3>

<p>Trong bài viết này tôi không tập trung vào cài đặt ELK, tuy nhiên tôi đã chuẩn bị sẵn một chút để start một ELK Stack nhỏ phục vụ công việc test collect/parse log tại <a href="https://github.com/ctnguyenvn/mini-elk-docker">đây</a>. Sau khi clone về bạn cần chạy script <code class="language-plaintext highlighter-rouge">init-lab.sh</code> để check một số thứ.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[admin@elk ~]$ git clone https://github.com/ctnguyenvn/mini-elk-docker
[admin@elk ~]$ cd mini-elk-docker
[admin@elk mini-elk-docker]$ bash init-lab.sh
[admin@elk mini-elk-docker]$ docker-compose up -d --build
</code></pre></div></div>

<p>Trong stack này hiện tại khi start lên logstash đã lắng nghe một số port nhất định như <code class="language-plaintext highlighter-rouge">5045/udp|tcp</code>, <code class="language-plaintext highlighter-rouge">5047/udp|tcp</code>,… Sau khi start ELK Stack chúng ta có thể truy cập vào giao diện của kibana tại địa chỉ <code class="language-plaintext highlighter-rouge">http://&lt;IP-Server&gt;:5601</code> với tài khoản <code class="language-plaintext highlighter-rouge">elastic/changeme</code></p>

<blockquote>
  <p>Lưu ý mặc định version ELK hiện tại đang thiết lập à 7.16.2, có thể thay đổi version bằng cách edit nội dung file <code class="language-plaintext highlighter-rouge">.env</code> tại thư mục <code class="language-plaintext highlighter-rouge">mini-elk-docker</code>.</p>
</blockquote>

<h3 id="cấu-hình-gửi-syslog-về-logstash-trên-cisco-ios">Cấu hình gửi syslog về logstash trên cisco ios</h3>

<p>Trước khi cấu hình syslog tôi thực hiện một vài config cơ bản như đặt hostname/IP hay tạo user… như sau. Truy cập vào console router 1 và thực hiện</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>R1# configure terminal
R1(config)# hostname Router1
Router1(config)# username admin01 privilege 15 password admin123

# cấu hình ssh/telnet service --&gt;

Router1(config)# ip domain-name congtrlab.local
Router1(config)# crypto key generate rsa  (lưu ý nên nhập key lenght 2048)
Router1(config)# ip ssh version 2
Router1(config)# ip ssh time-out 60

Router1(config)# line vty 0 4
Router1(config-line)# privilege level 15
Router1(config-line)# password admin
Router1(config-line)# login local
Router1(config-line)# transport input ssh telnet
Router1(config-line)# exit

# thiết lập IP Address --&gt;

Router1(config)# int f0/0
Router1(config-if)# ip address 172.16.0.140 255.255.255.0
Router1(config-if)# no shutdown
Router1(config-if)# end
Router1# write
</code></pre></div></div>

<blockquote>
  <p>Tương tự đối với router 2, lưu ý thay đổi thông tin IP address phù hợp theo sơ đồ. Đối với lab này không cần đến 2 router tuy nhiên để dể dàng phân biệt log trên các thiết bị nên tôi đã sử dụng 2 router cùng gửi log về SIEM để thoả mãn mong muốn này.</p>
</blockquote>

<p>Từ mô hình trên ta thấy ELK hiện tại đang có IP là <code class="language-plaintext highlighter-rouge">172.16.0.150</code> và logstash đang lắng nghe tại port <code class="language-plaintext highlighter-rouge">5047 UDP</code>. Để cấu hình gửi syslog về ELK tôi thực hiện như sau:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># cấu hình syslog server --&gt;

Router1# configure terminal
Router1(config)# logging userinfo
Router1(config)# logging host 172.16.0.150 transport udp port 5047
Router1(config)# logging trap notifications
Router1(config)# logging origin-id hostname

# cấu hình logging logon --&gt;

Router1(config)# login on-failure log
Router1(config)# login on-success log
Router1(config)# login block-for 60 attempts 3 within 60

# cấu hình logging command history --&gt;

Router1(config)# archive
Router1(config-archive)# log config
Router1(config-archive-log-cfg)# logging enable
Router1(config-archive-log-cfg)# hidekeys
Router1(config-archive-log-cfg)# notify syslog
Router1(config-archive-log-cfg)# end
Router1# write
</code></pre></div></div>
<blockquote>
  <p>Tương tự config đối với router 2. Ngoài ra bạn có thể thay thế log level tùy theo nhu cầu.</p>
</blockquote>

<h3 id="collect--parse-một-số-log-nhận-được-trên-logstash">Collect &amp; Parse một số log nhận được trên logstash</h3>

<p>Sau khi cấu hình thành công trên router, tôi thực hiện một vài thao tác như ssh vào router, test một vài command… và quay lại kibana kết quả:</p>

<p><img src="/images/ELK/cisco/2.png" alt="" /></p>

<p>Thực hiện tạo index trên Kibana Index Patterns</p>

<p><img src="/images/ELK/cisco/3.png" alt="" /></p>

<p>Quay lại Kibana Discover tôi được một số log với syslog format như sau</p>

<p><img src="/images/ELK/cisco/4.jpg" alt="" /></p>

<p>Tiếp theo để parse một số log logon và history command như yêu cầu ban đầu, tôi thực hiện chỉnh sửa <code class="language-plaintext highlighter-rouge">filter {}</code> trên pipeline config của logstash với nội dung như sau:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>admin@elk mini-elk-docker]<span class="nv">$ </span><span class="nb">cat </span>logstash/pipeline/logstash.conf

<span class="c"># input</span>
input <span class="o">{</span>
    udp <span class="o">{</span>
        port <span class="o">=&gt;</span> 5047
        <span class="nb">type</span> <span class="o">=&gt;</span> <span class="s2">"cisco"</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c"># filter</span>
filter <span class="o">{</span>
    <span class="k">if</span> <span class="o">[</span><span class="nb">type</span><span class="o">]</span> <span class="o">==</span> <span class="s2">"cisco"</span> <span class="o">{</span>
        grok <span class="o">{</span>
            match <span class="o">=&gt;</span> <span class="o">{</span>
                <span class="s2">"message"</span> <span class="o">=&gt;</span> <span class="s2">"&lt;%{NUMBER:priority}&gt;%{NUMBER:log.seq}: %{DATA:log.source}: %{DATA:event.datetime}: </span><span class="se">\%</span><span class="s2">%{WORD:facility}-%{INT:severity}-%{WORD:mnemonic}:( )?%{GREEDYDATA:msg}"</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="s2">"CFGLOG_LOGGEDCMD"</span> <span class="k">in</span> <span class="o">[</span>mnemonic]  <span class="o">{</span>
            grok <span class="o">{</span>
                match <span class="o">=&gt;</span> <span class="o">{</span>
                    <span class="s2">"msg"</span> <span class="o">=&gt;</span> <span class="s2">"User:%{USERNAME:user.name}%{SPACE}logged command:%{GREEDYDATA:user.command}"</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">else if</span> <span class="s2">"LOGIN_SUCCESS"</span> <span class="k">in</span> <span class="o">[</span>mnemonic] or <span class="s2">"LOGIN_FAILED"</span> <span class="k">in</span> <span class="o">[</span>mnemonic] <span class="o">{</span>
            grok <span class="o">{</span>
                match <span class="o">=&gt;</span> <span class="o">{</span>
                    <span class="s2">"msg"</span> <span class="o">=&gt;</span> <span class="s2">"Login %{WORD:event.status} </span><span class="se">\[</span><span class="s2">user: %{USERNAME:event.user}</span><span class="se">\]</span><span class="s2"> </span><span class="se">\[</span><span class="s2">Source: %{IPORHOST:event.source}</span><span class="se">\]</span><span class="s2"> </span><span class="se">\[</span><span class="s2">localport: %{NUMBER:event.service}</span><span class="se">\]</span><span class="s2"> (</span><span class="se">\[</span><span class="s2">Reason: %{DATA:event.reason}</span><span class="se">\]</span><span class="s2"> )?at %{GREEDYDATA:event.at}"</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">[</span>severity] <span class="o">{</span>
            translate <span class="o">{</span>
                <span class="nb">source</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">"severity"</span><span class="o">]</span>
                target <span class="o">=&gt;</span> <span class="s2">"[severity_desc]"</span>
                dictionary <span class="o">=&gt;</span> <span class="o">{</span>
                  <span class="s2">"0"</span> <span class="o">=&gt;</span> <span class="s2">"emergencies"</span>
                  <span class="s2">"1"</span> <span class="o">=&gt;</span> <span class="s2">"alerts"</span>
                  <span class="s2">"2"</span> <span class="o">=&gt;</span> <span class="s2">"critical"</span>
                  <span class="s2">"3"</span> <span class="o">=&gt;</span> <span class="s2">"errors"</span>
                  <span class="s2">"4"</span> <span class="o">=&gt;</span> <span class="s2">"warnings"</span>
                  <span class="s2">"5"</span> <span class="o">=&gt;</span> <span class="s2">"notifications"</span>
                  <span class="s2">"6"</span> <span class="o">=&gt;</span> <span class="s2">"informational"</span>
                  <span class="s2">"7"</span> <span class="o">=&gt;</span> <span class="s2">"debugging"</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c"># output</span>
output <span class="o">{</span>
    <span class="k">if</span> <span class="o">[</span><span class="nb">type</span><span class="o">]</span> <span class="o">==</span> <span class="s2">"cisco"</span> <span class="o">{</span>
        elasticsearch <span class="o">{</span>
          hosts <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">"http://es01:9200"</span><span class="o">]</span>
          index <span class="o">=&gt;</span> <span class="s2">"log-cisco-%{+YYYY.MM.dd}"</span>
          user <span class="o">=&gt;</span> <span class="s2">"elastic"</span>
          password <span class="o">=&gt;</span> <span class="s2">"changeme"</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p>Lưu ý <code class="language-plaintext highlighter-rouge">input {}</code> và <code class="language-plaintext highlighter-rouge">output {}</code> có thể không cần thay đổi, nếu muốn parse lại một số trường nào đó có thể thay đổi tại <code class="language-plaintext highlighter-rouge">filter {}</code>. Tất nhiên đây chỉ giới hạn trong một bài lab nhỏ mô phỏng toàn bộ quá trình collect &amp; parse log trên các thiết bị cisco ios.</p>
</blockquote>

<h3 id="kiểm-tra-kết-quả">Kiểm tra kết quả</h3>

<p>Sau khi lưu cấu hình tại pipeline của logstash, container logstash sẽ tự động reload lại config. Kết quả sau một vài thao tác bất kỳ như trên (SSH/execute command) trên kibaba tôi nhận được kết quả như mong muốn. Bạn có thể kiểm tra lại với log history command.</p>

<p><img src="/images/ELK/cisco/5.jpg" alt="" /></p>

<p>Lưu ý: Các field trong config parse log chỉ là tham khảo, bạn có thể tùy chỉnh theo nhu cầu.</p>

</div>
    <div class="gap-2 my-4">
        <a href="https://twitter.com/intent/tweet?text=Thu thập log từ Cisco IOS về SIEM (ELK)&url=https://ctnguyenvn.github.io/2023/02/collect-log-from-cisco-ios-to-ELK/" class="px-2 py-1 rounded bg-gray-800 hover:bg-yellow-400"><i class="bi bi-twitter-x text-gray-200 hover:text-gray-800"></i></a>
        <a href="https://www.facebook.com/sharer/sharer.php?u=https://ctnguyenvn.github.io/2023/02/collect-log-from-cisco-ios-to-ELK/" class="px-2 py-1 rounded bg-gray-800 hover:bg-yellow-400"><i class="bi bi-facebook text-gray-200 hover:text-gray-800"></i></a>
        <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://ctnguyenvn.github.io/2023/02/collect-log-from-cisco-ios-to-ELK/&title=Thu thập log từ Cisco IOS về SIEM (ELK)=&source=ctnguyenvn" class="px-2 py-1 rounded bg-gray-800 hover:bg-yellow-400"><i class="bi bi-linkedin text-gray-200 hover:text-gray-800"></i></a>
        <a href="https://reddit.com/submit?url=https://ctnguyenvn.github.io/2023/02/collect-log-from-cisco-ios-to-ELK/&title=Thu thập log từ Cisco IOS về SIEM (ELK)" class="px-2 py-1 rounded bg-gray-800 hover:bg-yellow-400"><i class="bi bi-reddit text-gray-200 hover:text-gray-800"></i></a>
    </div>
    <div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
        this.page.url = 'https://ctnguyenvn.github.io/2023/02/collect-log-from-cisco-ios-to-ELK/';
        this.page.identifier = 'ctnguyenvn';
    };
    (function () {
        var d = document,
            s = d.createElement('script');
        s.src = 'https://ctnguyenvn.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>
    Please enable JavaScript to view the
    <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>

</div>
</main>
			<div class="border-t bg-black">
<div class="max-w-screen-xl mx-auto flex flex-col px-2 py-6 text-center">
    <p class="text-gray-300">
        <strong>@2024</strong>
        by
        <a href="/" class="hover:text-yellow-400">ctnguyenvn</a>
        /
        <a href="/tags" class="hover:text-yellow-400">Tags</a>
        /
        <a href="/archive" class="hover:text-yellow-400">Archive</a>
    </p>
</div>
</div>
		</div>
        <script src="https://ctnguyenvn.github.io/assets/js/custom.js"></script>
    </body>
</html>
